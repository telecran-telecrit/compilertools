<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.44
     from /opt/src/gnu/flex-2.5.4/MISC/texinfo/flex.texi on 30 June 1997 -->

<TITLE>Flex - a scanner generator - Generating C++ scanners</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="flex_1.html">first</A>, <A HREF="flex_18.html">previous</A>, <A HREF="flex_20.html">next</A>, <A HREF="flex_25.html">last</A> section, <A HREF="index.html">table of contents</A>.
<HR>


<H2><A NAME="SEC19" HREF="index.html#SEC19">Generating C++ scanners</A></H2>

<P>
<CODE>flex</CODE> provides two different ways to generate scanners for
use with C++.  The first way is to simply compile a
scanner generated by <CODE>flex</CODE> using a C++ compiler instead of a C
compiler.  You should not encounter any compilations
errors (please report any you find to the email address
given in the Author section below).  You can then use C++
code in your rule actions instead of C code.  Note that
the default input source for your scanner remains <CODE>yyin</CODE>,
and default echoing is still done to <CODE>yyout</CODE>.  Both of these
remain <SAMP>`FILE *'</SAMP> variables and not C++ <CODE>streams</CODE>.

</P>
<P>
You can also use <CODE>flex</CODE> to generate a C++ scanner class, using
the <SAMP>`-+'</SAMP> option, (or, equivalently, <SAMP>`%option c++'</SAMP>), which
is automatically specified if the name of the flex executable ends
in a <SAMP>`+'</SAMP>, such as <CODE>flex++</CODE>.  When using this option, flex
defaults to generating the scanner to the file <TT>`lex.yy.cc'</TT> instead
of <TT>`lex.yy.c'</TT>.  The generated scanner includes the header file
<TT>`FlexLexer.h'</TT>, which defines the interface to two C++ classes.

</P>
<P>
The first class, <CODE>FlexLexer</CODE>, provides an abstract base
class defining the general scanner class interface.  It
provides the following member functions:

</P>
<DL COMPACT>

<DT><SAMP>`const char* YYText()'</SAMP>
<DD>
returns the text of the most recently matched
token, the equivalent of <CODE>yytext</CODE>.

<DT><SAMP>`int YYLeng()'</SAMP>
<DD>
returns the length of the most recently matched
token, the equivalent of <CODE>yyleng</CODE>.

<DT><SAMP>`int lineno() const'</SAMP>
<DD>
returns the current input line number (see <SAMP>`%option yylineno'</SAMP>),
or 1 if <SAMP>`%option yylineno'</SAMP> was not used.

<DT><SAMP>`void set_debug( int flag )'</SAMP>
<DD>
sets the debugging flag for the scanner, equivalent to assigning to
<CODE>yy_flex_debug</CODE> (see the Options section above).  Note that you
must build the scanner using <SAMP>`%option debug'</SAMP> to include debugging
information in it.

<DT><SAMP>`int debug() const'</SAMP>
<DD>
returns the current setting of the debugging flag.
</DL>

<P>
Also provided are member functions equivalent to
<SAMP>`yy_switch_to_buffer(), yy_create_buffer()'</SAMP> (though the
first argument is an <SAMP>`istream*'</SAMP> object pointer and not a
<SAMP>`FILE*'</SAMP>, <SAMP>`yy_flush_buffer()'</SAMP>, <SAMP>`yy_delete_buffer()'</SAMP>,
and <SAMP>`yyrestart()'</SAMP> (again, the first argument is a <SAMP>`istream*'</SAMP>
object pointer).

</P>
<P>
The second class defined in <TT>`FlexLexer.h'</TT> is <CODE>yyFlexLexer</CODE>,
which is derived from <CODE>FlexLexer</CODE>.  It defines the following
additional member functions:

</P>
<DL COMPACT>

<DT><SAMP>`yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )'</SAMP>
<DD>
constructs a <CODE>yyFlexLexer</CODE> object using the given
streams for input and output.  If not specified,
the streams default to <CODE>cin</CODE> and <CODE>cout</CODE>, respectively.

<DT><SAMP>`virtual int yylex()'</SAMP>
<DD>
performs the same role is <SAMP>`yylex()'</SAMP> does for ordinary
flex scanners: it scans the input stream, consuming
tokens, until a rule's action returns a value.  If you derive a subclass
<VAR>S</VAR>
from <CODE>yyFlexLexer</CODE>
and want to access the member functions and variables of
<VAR>S</VAR>
inside <SAMP>`yylex()'</SAMP>,
then you need to use <SAMP>`%option yyclass="<VAR>S</VAR>"'</SAMP>
to inform <CODE>flex</CODE>
that you will be using that subclass instead of <CODE>yyFlexLexer</CODE>.
In this case, rather than generating <SAMP>`yyFlexLexer::yylex()'</SAMP>,
<CODE>flex</CODE> generates <SAMP>`<VAR>S</VAR>::yylex()'</SAMP>
(and also generates a dummy <SAMP>`yyFlexLexer::yylex()'</SAMP>
that calls <SAMP>`yyFlexLexer::LexerError()'</SAMP>
if called).

<DT><SAMP>`virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)'</SAMP>
<DD>
reassigns <CODE>yyin</CODE> to <CODE>new_in</CODE>
(if non-nil)
and <CODE>yyout</CODE> to <CODE>new_out</CODE>
(ditto), deleting the previous input buffer if <CODE>yyin</CODE>
is reassigned.

<DT><SAMP>`int yylex( istream* new_in = 0, ostream* new_out = 0 )'</SAMP>
<DD>
first switches the input streams via <SAMP>`switch_streams( new_in, new_out )'</SAMP>
and then returns the value of <SAMP>`yylex()'</SAMP>.
</DL>

<P>
In addition, <CODE>yyFlexLexer</CODE> defines the following protected
virtual functions which you can redefine in derived
classes to tailor the scanner:

</P>
<DL COMPACT>

<DT><SAMP>`virtual int LexerInput( char* buf, int max_size )'</SAMP>
<DD>
reads up to <SAMP>`max_size'</SAMP> characters into <VAR>buf</VAR> and
returns the number of characters read.  To indicate
end-of-input, return 0 characters.  Note that
"interactive" scanners (see the <SAMP>`-B'</SAMP> and <SAMP>`-I'</SAMP> flags)
define the macro <CODE>YY_INTERACTIVE</CODE>.  If you redefine
<CODE>LexerInput()</CODE> and need to take different actions
depending on whether or not the scanner might be
scanning an interactive input source, you can test
for the presence of this name via <SAMP>`#ifdef'</SAMP>.

<DT><SAMP>`virtual void LexerOutput( const char* buf, int size )'</SAMP>
<DD>
writes out <VAR>size</VAR> characters from the buffer <VAR>buf</VAR>,
which, while NUL-terminated, may also contain
"internal" NUL's if the scanner's rules can match
text with NUL's in them.

<DT><SAMP>`virtual void LexerError( const char* msg )'</SAMP>
<DD>
reports a fatal error message.  The default version
of this function writes the message to the stream
<CODE>cerr</CODE> and exits.
</DL>

<P>
Note that a <CODE>yyFlexLexer</CODE> object contains its <EM>entire</EM>
scanning state.  Thus you can use such objects to create
reentrant scanners.  You can instantiate multiple instances of
the same <CODE>yyFlexLexer</CODE> class, and you can also combine
multiple C++ scanner classes together in the same program
using the <SAMP>`-P'</SAMP> option discussed above.
Finally, note that the <SAMP>`%array'</SAMP> feature is not available to
C++ scanner classes; you must use <SAMP>`%pointer'</SAMP> (the default).

</P>
<P>
Here is an example of a simple C++ scanner:

</P>

<PRE>
    // An example of using the flex C++ scanner class.

%{
int mylineno = 0;
%}

string  \"[^\n"]+\"

ws      [ \t]+

alpha   [A-Za-z]
dig     [0-9]
name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number  {num1}|{num2}

%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
            if(c == '\n')
                ++mylineno;

            else if(c == '*')
                {
                if((c = yyinput()) == '/')
                    break;
                else
                    unput(c);
                }
            }
        }

{number}  cout &#60;&#60; "number " &#60;&#60; YYText() &#60;&#60; '\n';

\n        mylineno++;

{name}    cout &#60;&#60; "name " &#60;&#60; YYText() &#60;&#60; '\n';

{string}  cout &#60;&#60; "string " &#60;&#60; YYText() &#60;&#60; '\n';

%%

Version 2.5               December 1994                        44

int main( int /* argc */, char** /* argv */ )
    {
    FlexLexer* lexer = new yyFlexLexer;
    while(lexer-&#62;yylex() != 0)
        ;
    return 0;
    }
</PRE>

<P>
If you want to create multiple (different) lexer classes,
you use the <SAMP>`-P'</SAMP> flag (or the <SAMP>`prefix='</SAMP> option) to rename each
<CODE>yyFlexLexer</CODE> to some other <CODE>xxFlexLexer</CODE>.  You then can
include <SAMP>`&#60;FlexLexer.h&#62;'</SAMP> in your other sources once per lexer
class, first renaming <CODE>yyFlexLexer</CODE> as follows:

</P>

<PRE>
#undef yyFlexLexer
#define yyFlexLexer xxFlexLexer
#include &#60;FlexLexer.h&#62;

#undef yyFlexLexer
#define yyFlexLexer zzFlexLexer
#include &#60;FlexLexer.h&#62;
</PRE>

<P>
if, for example, you used <SAMP>`%option prefix="xx"'</SAMP> for one of
your scanners and <SAMP>`%option prefix="zz"'</SAMP> for the other.

</P>
<P>
IMPORTANT: the present form of the scanning class is
<EM>experimental</EM> and may change considerably between major
releases.

</P>
<HR>
Go to the <A HREF="flex_1.html">first</A>, <A HREF="flex_18.html">previous</A>, <A HREF="flex_20.html">next</A>, <A HREF="flex_25.html">last</A> section, <A HREF="index.html">table of contents</A>.
</BODY>
</HTML>
