<HTML>

<head>
<title>Writing an Interpreter with Lex, Yacc, and Memphis</title>

<META name="keywords"
content="C/C++, lex and Yacc, scanner, parser, abstract syntax,
trees, tree, builder, tree walker, pattern matching,
compiler construction, language translation">

<META name="description"
content="Explains how to write an interpreter for little programming language">

</head>
<body bgcolor="#f9c674">
<TABLE cellspacing=20>
<TR>
<TD>
<img src="croco.gif">
</TD>
<TD valign=top align=left>
<a href="index.html">The Memphis Tree Builder & Tree Walker Tool</a>
<H1>
Writing an Interpreter<br>
with Lex, Yacc, and Memphis
</H1>
</TD>
</TR>
<TR>
<!-- MENU -->
<TD valign=top align=center>
<font face="helvetica">
<A HREF="index.html">Memphis</A>
<br>
<A HREF="examples.html">Examples</A>
<br>
<A HREF="manuals.html">Manuals</A>
<br>
<A HREF="distribution.html">Distribution</A>
</font>
<p>
</TD>
<!-- MAINPART -->
<TD>
<!-- ======================================================================= -->
Here is a small example that shows how to write an interpreter
with Lex, Yacc, and Memphis.
<p>
Our example language provides arithmetic and relational expressions
as well as assignment and print statements.
To structure programs it features conditional and repetitive statements
and the possibility to group statements to sequences.
<p>
Here is a typical program in our example language:
<p>
<pre>
   // Greatest Common Divisor
   x := 8;
   y := 12;
   WHILE x != y DO
      IF x > y THEN x := x-y
      ELSE y := y-x
      FI
   OD;
   PRINT x
</pre>
<p>
Our processor for this language will be decomposed into two parts.
<p>
The task of the first part (the <b>analizer</b>)
is to read the source program and to
discover its structure.
<p>
The task of the second part (the <b>tree walker</b>)
is to process this structure, thereby evaluating
expressions and executing statements.
<p>
The <b>glue</b> between these parts is an abstract program representation.
<h2>The Analizer</h2>
The task to structure the program is decomposed into
lexical analysis and syntactical analysis.
<p>
<b>Lexical analysis</b> splits the source text into a sequence of tokens,
skipping blanks, newlines, and comments.
For example, the source text
<p>
<pre>
   x :=   // multiply x
   x*100  // by hundred
</pre>
<p>
is handled as the sequence of tokens
<pre>
   x
   :=
   x
   *
   100
</pre>
<p>
Each token belongs to a token class.
There are simple tokens such as ``<tt>:=</tt>'', it belongs to the class
<tt>ASSIGN</tt> which has only this member.
And there are more complex tokens such <tt>100</tt>, it belongs to the class
<tt>Number</tt> which comprises the strings that form decimal numbers.
Simple tokens can be specified simply by the string that represents them.
Complex tokens are defined by a <i>regular expression</i>
that covers the strings of the token class. For example,
the regular expression
<p>
<pre>
   [0-9]+
</pre>
<p>
specifies nonempty sequences of decimal digits.
In case of simple tokens we just need to know the token class,
in case of complex tokens some additional processing is neccessary.
E.g. the strings that matches the regular expression for numbers
must be converted to an integer that holds its numerical value.
<p>
The lexical analysis is implemented by a function <tt>yylex()</tt>
that reads a token from the input stream and
returns its name (token class).
In addition, it assign the semantic value (e.g. of numbers) to
the global variable <tt>yylval</tt>.
<p>
Such a function can be generated by the tool Lex.
Its input is  a set of pairs
<pre>
regular-expression { action }
</pre>
The action is performed when the current input matches the regular expression.
For example,
<p>
<pre>
   ":=" { return ASSIGN; }
</pre>
<p>
defines <tt>ASSIGN</tt> tokens and
<p>
<pre>
   [0-9]+ { yylval = atoi(yytext); return NUMBER; }
</pre>
<p>
specifies how to handle numbers.
<p>
Here is the input to Lex:
<p>
<table>
<tr>
<td bgcolor="white">
<font size="-2">
<pre>
<p>
   %{
   #include "y.tab.h"
   extern int yylval;
   %}
   %%
   "="      { return EQ; }
   "!="     { return NE; }
   "<"      { return LT; }
   "<="     { return LE; }
   ">"      { return GT; }
   ">="     { return GE; }
   "+"      { return PLUS; }
   "-"      { return MINUS; }
   "*"      { return MULT; }
   "/"      { return DIVIDE; }
   ")"      { return RPAREN; }
   "("      { return LPAREN; }
   ":="     { return ASSIGN; }
   ";"      { return SEMICOLON; }
   "IF"     { return IF; }
   "THEN"   { return THEN; }
   "ELSE"   { return ELSE; }
   "FI"     { return FI; }
   "WHILE"  { return WHILE; }
   "DO"     { return DO; }
   "OD"     { return OD; }
   "PRINT"  { return PRINT; }
   [0-9]+   { yylval = atoi(yytext); return NUMBER; }
   [a-z]    { yylval = yytext[0] - 'a'; return NAME; }   
   \        { ; }
   \n       { nextline(); }
   \t       { ; }
   "//".*\n { nextline(); }
   .        { yyerror("illegal token"); }
   %%
   #ifndef yywrap
   yywrap() { return 1; }
   #endif

</pre>
</td>
</tr>
</table>
<p>
<b>Syntactical analysis</b> imposes a hierarchical structure on the program.
This structure is specified by the rules of a <i>context-free grammar</i>.
A syntactical phrase is introduced by giving one or more alternatives.
An alternative specifies how to construct an instance of the phrase.
It list the members that build up the phrase, where such a member is
either atoken or the name of a phrase (a <i>nonterminal</i>).
<p>
Consider the rule to define <tt>statement</tt>s:
<p>
<pre>
   statement:
     designator ASSIGN expression
   | PRINT expression
   | IF expression THEN stmtseq ELSE stmtseq FI
   | IF expression THEN stmtseq FI
   | WHILE expression DO stmtseq OD
   ;
</pre>
<p>
For example, the first alternative specifies that if <i>D</i>
is a <tt>designator</tt> and if <i>E</i> is an <tt>expression</tt> then
<i>D</i> <tt>:=</tt> <i>E</i>
is a <tt>statement</tt>.
<p>
We use the tool Yacc to generate the syntactical analizer.
Its input is a context-free grammar from which it creates a function
<tt>yyparse()</tt> that parses the source text according to that grammar.
(<tt>yyparse()</tt> invokes <tt>yylex()</tt> to obtain the next token).
<p>
With rules like the one given above, <tt>yyparse()</tt> would only be able
to check whether a given source is consistent with the grammar.
As we did with the Lex specification, we attach semantic actions.
They are executed whenever an alternative matches a phrase of the input
and are used to construct an abstract program representation.
<p>
The rule for <tt>statement</tt> becomes:
<p>
<pre>
 statement:
   designator ASSIGN expression {$$ = assignment($1, $3);} 
 | PRINT expression {$$ = print($2);} 
 | IF expression THEN stmtseq ELSE stmtseq FI
     {$$ = ifstmt($2, $4, $6);}
 | IF expression THEN stmtseq FI
     {$$ = ifstmt($2, $4, empty());}
 | WHILE expression DO stmtseq OD {$$ = whilestmt($2, $4);}
 ;
</pre>
<p>
Consider again the first alternative.
The semantic action attached to it constructs an abstract representation
of an assignment statement and defines this as the structural value
of the phrase, i.e. it assigns it to the special variable <tt>$$</tt>.
the value is constructed by applying the function <tt>assignment()</tt>
to the value of the first member (<tt>designator</tt>), denoted by
<tt>$1</tt>, and the value of the third member (<tt>expression</tt>),
denoted by <tt>$3</tt>.
<p>
Here is the input to Yacc:
<p>
<table>
<tr>
<td bgcolor="white">
<font size="-2">
<pre>
<p>
   %start ROOT

   %token EQ
   %token NE
   %token LT
   %token LE
   %token GT
   %token GE
   %token PLUS
   %token MINUS
   %token MULT
   %token DIVIDE
   %token RPAREN
   %token LPAREN
   %token ASSIGN
   %token SEMICOLON
   %token IF
   %token THEN
   %token ELSE
   %token FI
   %token WHILE
   %token DO
   %token OD
   %token PRINT
   %token NUMBER
   %token NAME

   %%

   ROOT:
     stmtseq { execute($1); } 
   ;

   statement:
     designator ASSIGN expression { $$ = assignment($1, $3); } 
   | PRINT expression { $$ = print($2); } 
   | IF expression THEN stmtseq ELSE stmtseq FI
	{ $$ = ifstmt($2, $4, $6); }
   | IF expression THEN stmtseq FI
	{ $$ = ifstmt($2, $4, empty()); }
   | WHILE expression DO stmtseq OD { $$ = whilestmt($2, $4); }   
   ;

   stmtseq:
     stmtseq SEMICOLON statement { $$ = seq($1, $3); }
   | statement { $$ = $1; }
   ;

   expression:
     expr2 { $$ = $1; } 
   | expr2 EQ expr2 { $$ = eq($1, $3); }
   | expr2 NE expr2 { $$ = ne($1, $3); }
   | expr2 LT expr2 { $$ = le($1, $3); }
   | expr2 LE expr2 { $$ = le($1, $3); }
   | expr2 GT expr2 { $$ = gt($1, $3); }
   | expr2 GE expr2 { $$ = gt($1, $3); }
   ;

   expr2:
     expr3 { $$ == $1; }
   | expr2 PLUS expr3 { $$ = plus($1, $3); }
   | expr2 MINUS expr3 { $$ = minus($1, $3); }
   ;

   expr3:
     expr4 { $$ = $1; }
   | expr3 MULT expr4 { $$ = mult($1, $3); }
   | expr3 DIVIDE expr4 { $$ = divide ($1, $3); }
   ;

   expr4:
     PLUS expr4 { $$ = $2; }
   | MINUS expr4 { $$ = neg($2); }
   | LPAREN expression RPAREN { $$ = $2; }
   | NUMBER { $$ = number($1); }
   | designator { $$ = $1; }
   ;

   designator:
     NAME { $$ = name($1); }
   ;

</pre>
</td>
</tr>
</table>
<h2>The Glue</h2>
As we have seen  with <tt>assignment()</tt>, 
the abstract representation,
or <i>abstract syntax</i>,
is constructed by functions
that take the representation of constituents and build the representation of
a larger construct.
<p>
This results in a tree structure: the functions construct nodes
whose childs are subtrees representing the constituents.
<p>
In language processors the abstract syntax
plays a central role. It does not only define the glue between passes,
it also determines the design of functions that process the
program: they often inductively follow the structure of the abstract
representation.
<p>
Hence it is a good idea to provide a clean definition.
We classify the nodes into into node types and list the types of its childs.
<p>
For our example language we introduce two node types:
<tt>Statement</tt> and <tt>Expression</tt>.
An example of nodes of type <tt>Statement</tt>
is <tt>assignment</tt> that takes two arguments (<tt>lhs</tt> and <tt>rhs</tt>)
of type <tt>Expression</tt>. This is specified by listing
<p>
<pre>
   assignment (Expression lhs, Expression rhs)
</pre>
<p>
as an alternative of type <tt>Statement</tt>.
<p>
We use domain declarations for the specification.
<p>
For example, <tt>Statement</tt> is introduced by a declaration of the form
<p>
<pre>
   domain Statement {
      ...
   }
</pre>
<p>
that lists the <tt>Statement</tt> alternatives.
One of them is
<p>
<pre>
   assignment (Expression lhs, Expression rhs)
</pre>
<p>
Here is the complete definition of the abstract syntax:
<p>
<table>
<tr>
<td bgcolor="white">
<font size="-2">
<pre>

   domain Statement {

      assignment (Expression lhs, Expression rhs)
      print (Expression x)
      ifstmt (Expression cond, Statement thenpart, Statement elsepart)   
      whilestmt (Expression cond, Statement body)
      seq (Statement s1, Statement s2)
      empty ()

   }

   domain Expression {

      eq (Expression x, Expression y)
      ne (Expression x, Expression y)
      lt (Expression x, Expression y)
      le (Expression x, Expression y)
      gt (Expression x, Expression y)
      ge (Expression x, Expression y)
      plus (Expression x, Expression y)
      minus (Expression x, Expression y)
      mult (Expression x, Expression y)
      divide (Expression x, Expression y)
      neg (Expression x)
      number (int x)
      name (int location)

   }

</pre>
</td>
</tr>
</table>
<p>
Note that this definition can be read as a grammar defining the abstract
syntax.
<p>
The definition not only provides documentation (as it is valuable even
if we  write the corresponding C/C++ data types
and the functions manually),
it also enables the Memphis precompiler to generate the implementation
automatically.
<h2>The Tree Walker</h2>
We are now ready to write the tree walker.
<p>
It will consist of two functions (one for each domain of the abstract syntax):
<tt>evaluate (Expression e)</tt>
that evaluates an <tt>Expression</tt> <tt>e</tt>
and returns its numerical value,
and
<tt>execute (Statement s)</tt>
that executes a <tt>Statement</tt> <tt>s</tt>.
<p>
Such functions are generally written by providing a piece of code for
each possible alternative of the argument, where this code recursively
visits the constituents the argument.
<p>
In Memphis we can use the <tt>match</tt> statement to describe
this style of processing.
<p>
The <tt>evaluate</tt> function takes the form
<p>
<pre>
   int evaluate(Expression e)
   {
      match e {
         ...
      }
   }
</pre>
<p>
The body of the <tt>match</tt> statement
lists specific rules that handle the <tt>Expression</tt> <tt>e</tt>
according to its structure.
<p>
One of these rules is
<p>
<pre>
   rule plus(x, y) : return evaluate(x) + evaluate(y);
</pre>
<p>
If <tt>e</tt> has the form <tt>plus(x, y)</tt>
then this rule is applied.
It recursively evaluates <tt>x</tt> and <tt>y</tt>
and returns the sum of their numerical values.
<p>
Here is the tree walker:
<p>
<table>
<tr>
<td bgcolor="white">
<font size="-2">
<pre>

   with ast;

   extern "C" printf(...);
   extern "C" execute(Statement s);

   int var[26];

   int evaluate(Expression e)
   {
      match e {
	 rule eq(x, y)     :  return evaluate(x) == evaluate(y);   
	 rule ne(x, y)     :  return evaluate(x) != evaluate(y);
	 rule lt(x, y)     :  return evaluate(x) <  evaluate(y);
	 rule le(x, y)     :  return evaluate(x) <= evaluate(y);
	 rule gt(x, y)     :  return evaluate(x) >  evaluate(y);
	 rule ge(x, y)     :  return evaluate(x) >= evaluate(y);
	 rule plus(x, y)   :  return evaluate(x) +  evaluate(y);
	 rule minus(x, y)  :  return evaluate(x) -  evaluate(y);
	 rule mult(x, y)   :  return evaluate(x) *  evaluate(y);
	 rule divide(x, y) :  return evaluate(x) /  evaluate(y);
	 rule neg(x)       :  return - evaluate(x);
	 rule number(x)    :  return x;
	 rule name(x)      :  return var[x];
      }
   }

   execute (Statement s)
   {
      match s {
	 rule assignment(name(x), rhs) :
	    var[x] = evaluate(rhs);
	 rule print(x) :
	    printf("%d\n", evaluate(x));
	 rule ifstmt(c, s1, s2) :
	    if(evaluate(c)) execute(s1); else execute(s2);
	 rule whilestmt(c, s) :
	    while(evaluate(c)) execute(s);
	 rule seq(s1, s2) :
	    execute(s1); execute(s2);
	 rule empty() :
	    ;
      }
   }

</pre>
</td>
</tr>
</table>
<p>
Note that this notation is similar to the Yacc style.
A syntactic pattern is followed by an associated action.
But here the pattern describes abstract syntax
instead of concrete source text.
<p>
Again, the notation is more concise than the corresponding manual
implementation. The Memphis precompiler not only generates the
implementation, it also allows to check statically
that constituents are only used in a context where they are indeed fields
of the actual item.
<!-- ======================================================================= -->
</TD>
<!-- END MAINPART -->
</TR>
</TABLE>
</body>
</html>
